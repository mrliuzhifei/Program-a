C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BC3602
OBJECT MODULE PLACED IN .\Output\BC3602.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE ..\..\..\UserCode\User\src\BC3602.c LARGE OPTIMIZE(7,SPEED) BROWSE INCDI
                    -R(..\..\..\UserCode\Device\Include;..\..\..\UserCode\StdDriver\inc;..\..\..\UserCode\User\ins;..\..\..\UserCode\StdDrive
                    -r\src;..\..\..\UserCode\StdDriver\lib) DEBUG OBJECTEXTEND PRINT(.\LST\BC3602.lst) TABS(2) OBJECT(.\Output\BC3602.obj)

line level    source

   1          #include "BC3602.h"
   2          #include "BC3602_CMD_REG.h"
   3          #include "BC3602_SPI.h"
   4          #include "ML51.h"
   5          //#include "BC3602_CONFIG_TABLE.h"
   6          #include "BC3602_Gateway.h"//
   7          
   8          unsigned char RF_TXFIFO[RF_Payload_Length];   //FIFO length defined in Configuration.h
   9          unsigned char RF_RXFIFO[RF_Payload_Length];   //FIFO length defined in Configuration.h
  10          unsigned char RF_RXFIFOSAVE[RF_Payload_Length];   //FIFO length defined in Configuration.h
  11          unsigned char RF_IRQ;
  12          
  13          
  14          
  15          unsigned char mRFSync[RF_SYNC_Length];      //SYNC length defined in Configuration.h
  16          struct define_flag
  17          {
  18            unsigned char Key_Stas;                                 // KEY states
  19            unsigned char LED_Stas;                                 // LED states
  20            unsigned char RFmode;                                 // RF_MODE
  21            unsigned char RFstep;                                 // RF process step
  22            unsigned char fRFINT:1;                                 // RF interrupt flag
  23            unsigned char f8ms:1;                                 // MCU timebase time-out 8ms flag
  24          };
  25          struct define_flag Mflag;
  26          
  27          
  28          /*------------------------------------------------------------------*/
  29          /*               Function               */
  30          /*------------------------------------------------------------------*/
  31          //*******************************//
  32          // name   : SpiWriteRegCMD
  33          // input  : CMD,DATA
  34          // output : none
  35          //*******************************//
  36          void SpiWriteRegCMD(unsigned char CMD,unsigned char DATA)
  37          {
  38   1        //SpiCSN_low();
  39   1        BC3602CSN=0 ;
  40   1        SpiWrite(CMD);
  41   1        SpiWrite(DATA);
  42   1        //SpiCSN_high();
  43   1        BC3602CSN=1 ;
  44   1      }
  45          
  46          //*******************************//
  47          // name   : SpiWriteByte
  48          // input  : CMD
  49          // output : ReadDATA
  50          //*******************************//
  51          unsigned char SpiReadRegCMD(unsigned char CMD)
  52          {
  53   1        unsigned char ReadDATA;
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 2   

  54   1        //SpiCSN_low();
  55   1        BC3602CSN=0 ;
  56   1        SpiWrite(CMD);
  57   1        ReadDATA = SpiRead();
  58   1        //SpiCSN_high();
  59   1        BC3602CSN=1 ;
  60   1        return  ReadDATA;
  61   1      }
  62          
  63          //*******************************//
  64          // name   : SpiWriteStrobeCMD
  65          // input  : CMD
  66          // output : none
  67          //*******************************//
  68          void SpiWriteStrobeCMD(unsigned char CMD)
  69          {
  70   1        //SpiCSN_low();
  71   1        BC3602CSN=0 ;
  72   1        SpiWrite(CMD);
  73   1        //SpiCSN_high();
  74   1        BC3602CSN=1 ;
  75   1      }
  76          
  77          
  78          
  79          //*******************************//
  80          // name   : RFWriteFreq
  81          // input  : none
  82          // output : none
  83          //*******************************//
  84          /*void RFWriteFreq(void)
  85          {
  86            unsigned char a=0;
  87            a = SpiReadRegCMD(READ_REGS_CMD|OM_REGS);           //ËØªÂèñOM_REGSÂ∑•‰ΩúÊ®°ÂºèÂØÑÂ≠òÂô®Áä∂ÊÄ?
  88            a = (a&0x9f)|BAND_SEL;                              //ÂèñBAND_SEL‰∏?0X20ÔºåÂç≥ÈÄâÊã©433MÈ¢ëÊ??
  89            SpiWriteRegCMD(WRITE_REGS_CMD|OM_REGS,a);           //ÊääÈÖçÁΩ?ÂÜôÂÖ•OM_REGSÂ∑•‰ΩúÊ®°ÂºèÂØÑÂ≠òÂô?  ËÆæÁΩÆ
             -È¢ëÊ?µÊàêÂä?
  90            
  91            for(a=0;a<(sizeof Frequency_REGS_TALBE/2);a++)  SpiWriteRegCMD((WRITE_REGS_CMD|(Frequency_REGS_TALBE[a]>>8
             -)), Frequency_REGS_TALBE[a]);
  92          }*/
  93          
  94          //*******************************//
  95          // name   : RFSetDRPram
  96          // input  : none
  97          // output : none
  98          //*******************************//
  99          /*void RFSetDRPram(void)
 100          {
 101            unsigned char a=0;
 102            SpiWriteStrobeCMD(REGS_BANK_CMD|BC3602_BANK0);   //ÈÄâÊã©BANK0
 103            for(a=0;a<(sizeof DM_REGS_TALBE/2);a++) SpiWriteRegCMD((WRITE_REGS_CMD|(DM_REGS_TALBE[a]>>8)), DM_REGS_TA
             -LBE[a]);
 104            SpiWriteStrobeCMD(REGS_BANK_CMD|BC3602_BANK1);
 105            for(a=0;a<(sizeof FCF_REGS_TALBE/2);a++)  SpiWriteRegCMD((WRITE_REGS_CMD|(FCF_REGS_TALBE[a]>>8)), FCF_REGS
             -_TALBE[a]);
 106            SpiWriteStrobeCMD(REGS_BANK_CMD|BC3602_BANK2);
 107            for(a=0;a<(sizeof CBPF_REGS_TALBE/2);a++) SpiWriteRegCMD((WRITE_REGS_CMD|(CBPF_REGS_TALBE[a]>>8)), CBPF_R
             -EGS_TALBE[a]);
 108            SpiWriteStrobeCMD(REGS_BANK_CMD|BC3602_BANK0);
 109          }*/
 110          
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 3   

 111          /*void RFSetPower(unsigned char band_sel,unsigned char power)
 112          {
 113            SpiWriteRegCMD(WRITE_REGS_CMD|TX2_REGS,TxPowerValue[band_sel][power]);
 114          }*/
 115          
 116          //*******************************//
 117          // name   : RFXtalReady
 118          // input  : none
 119          // output : none
 120          //*******************************//
 121          /*void RFXtalReady(void)
 122          {
 123            unsigned char a=0;
 124            while(a == 0)
 125            {
 126              a=SpiReadRegCMD(READ_REGS_CMD|RC1_REGS);
 127              a &= 0x20;
 128            }
 129          }*/
 130          
 131          //*******************************//
 132          // name   : RFCalibration
 133          // input  : none
 134          // output : none
 135          //*******************************//
 136          /*void RFCalibration(void)
 137          {
 138            unsigned char a=0;
 139            a=SpiReadRegCMD(READ_REGS_CMD|OM_REGS);
 140            a |= 0x08;
 141            SpiWriteRegCMD(WRITE_REGS_CMD|OM_REGS,a);
 142            while(a)
 143            {
 144              a=SpiReadRegCMD(READ_REGS_CMD|OM_REGS);
 145              a &= 0x08;
 146            }
 147          }*/
 148          
 149          
 150          //*******************************//
 151          // name   : LircCalibration
 152          // input  : none
 153          // output : none
 154          //*******************************//
 155          /*void LircCalibration(void)
 156          {
 157            unsigned char a=0;
 158            a=SpiReadRegCMD(READ_REGS_CMD|XO3_REGS);
 159            a |= 0x81;
 160            SpiWriteRegCMD(WRITE_REGS_CMD|XO3_REGS,a);
 161            while(a)
 162            {
 163              a=SpiReadRegCMD(READ_REGS_CMD|XO3_REGS);
 164              a &= 0x80;
 165            }
 166          }*/
 167          
 168          //*******************************//
 169          // name   : RFGetClrRFIrq
 170          // input  : none
 171          // output : irq_status
 172          //*******************************//
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 4   

 173          /*unsigned char RFGetClrRFIrq(void)
 174          {
 175            unsigned char irq;
 176            
 177            irq=SpiReadRegCMD(READ_REGS_CMD|IRQ3_REGS);
 178            SpiWriteRegCMD(WRITE_REGS_CMD|IRQ3_REGS,irq);
 179            
 180            return irq;
 181          }*/
 182          
 183          void BC3602_InterfaceConfigure(void)//Ω”ø⁄≈‰÷√
 184          {
 185   1        
 186   1        /*Syncword[0]=0x54;//¡Ÿ ±∑≈”⁄¥À
 187   1        Syncword[1]=0x52;//¡Ÿ ±∑≈”⁄¥À
 188   1        Syncword[2]=0x4e;//¡Ÿ ±∑≈”⁄¥À
 189   1        Syncword[3]=0x49;//¡Ÿ ±∑≈”⁄¥À*/
 190   1        
 191   1        
 192   1        BC3602_SPI_IOConfig();
 193   1        
 194   1        //GCC_DELAY(200); //100us 
 195   1          
 196   1        DISABLE_GLOBAL_INTERRUPT;                 // ÔøΩÿ±ÔøΩ»´ÔøΩÔøΩÔøΩ–∂ÔøΩ
 197   1          /**********ÔøΩÔøΩÔøΩÔøΩÔøΩ¬ΩÔøΩÔøΩÔøΩÔøΩ–∂ÔøΩ**************************/
 198   1        MFP_P13_GPIO;
 199   1          GPIO_SetMode(Port1,BIT3,GPIO_MODE_INPUT);                              /* set P2.5 as input output mod
             -e */
 200   1          GPIO_Pull_Enable(Port1,BIT3,PULLUP );
 201   1          GPIO_EnableInt(PIT0,FALLING,EDGE,1,3);         /* Setting pin intterrupt channel 0 as P2.5 falling edg
             -e trigger. */
 202   1          
 203   1      
 204   1          ENABLE_GLOBAL_INTERRUPT;      
 205   1         
 206   1        BC3602_WriteRegister(CONFIG_REGS,0x00);
 207   1        
 208   1        //reset 1.2V  
 209   1        BC3602_WriteRegister(CLOCK_CTL_REGS,0x10);
 210   1        BC3602_WriteRegister(CLOCK_CTL_REGS,0x11);
 211   1        BC3602_WriteRegister(CLOCK_CTL_REGS,0x10);  
 212   1        
 213   1        // enter light sleep mode 
 214   1        BC3602_EnterLightSleep();
 215   1        
 216   1        //software reset
 217   1        BC3602_SoftwareReset();
*** WARNING C206 IN LINE 217 OF ..\..\..\UserCode\User\src\BC3602.c: 'BC3602_SoftwareReset': missing function-prototype
 218   1      
 219   1        // register bank change to 0 
 220   1        BC3602_RegisterBank(REGS_BANK0);
 221   1      
 222   1        BC3602_CrystalReady();
*** WARNING C206 IN LINE 222 OF ..\..\..\UserCode\User\src\BC3602.c: 'BC3602_CrystalReady': missing function-prototype
 223   1      }
 224          
 225          void RF_Init(void)
 226          {
 227   1        //SpiIOInti();                             // RF SPI I/O Initialization
 228   1         BC3602_SPI_IOConfig();                    // SPI≥ı ºªØ
 229   1        BC3602_EnterLightSleep();
 230   1        BC3602_RegisterBank(REGS_BANK0);
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 5   

 231   1        BC3602_WriteRegister(CONFIG_REGS,0x40);//0x00 AGC πƒ‹ RX¡¨–¯ƒ£ Ω≥˝ƒ‹
 232   1        BC3602_WriteRegister(CLOCK_CTL_REGS,0xb0);//
 233   1        //BC3602_WriteRegister(IRQ_CTL_REGS,0x02);//ºÏ≤‚‘ÿ≤®(Carry)
 234   1        //BC3602_WriteRegister(IRQ_CTL_REGS,0x06);//ºÏ≤‚«∞µº¬Î(Preamble)
 235   1        BC3602_WriteRegister(IRQ_CTL_REGS,0x0a);//ºÏ≤‚Õ¨≤Ω¬Î(SYNCWORD)
 236   1        BC3602_WriteRegister(IRQ_ENABLE_REGS,0x01);//TXÕÍ≥…IRQ
 237   1        BC3602_WriteRegister(IRQ_STATUS_REGS,0x00);//0x04
 238   1      //  BC3602_WriteRegister(GPIO12_CTL_REGS,0xe9);//4 line spi,GIO1 is SDO and GIO2 is IRQ
 239   1        BC3602_WriteRegister(GPIO12_CTL_REGS,0x45);//0x06 3 line spi,GIO1 is no function and GIO2 is IRQ
 240   1        BC3602_WriteRegister(GPIO34_CTL_REGS,0x00);//GIO4 is no function and GIO3 is no function
 241   1        BC3602_WriteRegister(GPIO_PULL_UP_REGS,0xb9);//0b10111001
 242   1        BC3602_WriteRegister(TX_FIFO_SA_REGS,0x00);//
 243   1        BC3602_WriteRegister(FIFO2_CTL_REGS,0x01);//FIFO≥§∂»±ﬂΩÁ—°‘Ò TX 8 byte and RX 8 byte
 244   1        BC3602_WriteRegister(PREAMBLE_LENG_REGS,0x03);//0x0b «∞µº¬Î≥§∂»=3+1=4 byte
 245   1        BC3602_WriteRegister(PACKET_CTL2_REGS,0x07);//Õ¨≤Ω¬Î=4 byte,RX«∞µº¬ÎºÏ≤‚≥§∂»=4 byte
 246   1        BC3602_WriteRegister(PACKET_CTL3_REGS,0x00);//
 247   1        BC3602_WriteRegister(PACKET_CTL4_REGS,0x36);//
 248   1        BC3602_WriteRegister(TX_DATA_LENG_REGS,0x05);//
 249   1        BC3602_WriteRegister(RX_DATA_LENG_REGS,0x00);//
 250   1        BC3602_WriteRegister(TRX_MODE_DELAY_REGS,0x20);//
 251   1        BC3602_WriteRegister(HEADER_ADDR0_REGS,0x00);//
 252   1        BC3602_WriteRegister(HEADER_ADDR1_REGS,0x00);//
 253   1        BC3602_WriteRegister(MODULATOR_CTL1_REGS,0x05);//MOD1 DataRate=fXTAL/((XODIV2+1)*32*(DTR[8:0]+1))=19.2M/(
             -(0+1)*32*(5+1))=100K  for 19.2M
 254   1        BC3602_WriteRegister(MODULATOR_CTL2_REGS,0x60);//
 255   1        BC3602_WriteRegister(MODULATOR_CTL3_REGS,0x66);//
 256   1        BC3602_WriteRegister(DEMOULATOR_CTL1_REGS,0x0b);//for 19.2M
 257   1        BC3602_WriteRegister(DEMOULATOR_CTL2_REGS,0x40);//
 258   1        BC3602_WriteRegister(DEMOULATOR_CTL3_REGS,0xe0);//
 259   1        BC3602_WriteRegister(DEMOULATOR_CTL4_REGS,0x18);//
 260   1        BC3602_WriteRegister(DEMOULATOR_CTL5_REGS,0x30);//
 261   1        BC3602_WriteRegister(DEMOULATOR_CTL8_REGS,0x15);//
 262   1        BC3602_WriteRegister(OPERATION_CTL_REGS,0x20);//
 263   1        BC3602_WriteRegister(FRACTIONAL_N_DN_REGS,0x16 );//433.301M/19.2M=22.5678 ’˚ ˝≤ø∑÷ for 19.2M///////***///
             -///////
 264   1        BC3602_WriteRegister(FRACTIONAL_N_DKL_REGS,0x8c);//
 265   1        BC3602_WriteRegister(FRACTIONAL_N_DKM_REGS,0x15);//
 266   1        BC3602_WriteRegister(FRACTIONAL_N_DKH_REGS,0x09);//
 267   1        BC3602_WriteRegister(MODE_STATUS_REGS,2);        // for 19.2M 2020.12.26
 268   1        BC3602_WriteRegister(RSSI_CTL_REGS,10);          //
 269   1        BC3602_WriteRegister(RSSI_VALUE_REGS,0);         //
 270   1        BC3602_WriteRegister(RSSI_VALUE_ID_REGS,0);      //
 271   1        BC3602_WriteRegister(ATR_CONTROL_REGS,0x4a);     //ATR1 ◊‘∂ØTX/RXøÿ÷∆ºƒ¥Ê∆˜
 272   1        
 273   1      //  BC3602_WriteRegister(ATR_CYCLE_L_REGS,0x0a);//ATR2 ATRCT∂® ±∆˜ΩÁœﬁ÷µµÕ◊÷Ω⁄
 274   1      //  BC3602_WriteRegister(ATR_CYCLE_H_REGS,0x77);//ATR3 ATRCT∂® ±∆˜ΩÁœﬁ÷µ∏ﬂ◊÷Ω⁄ ªΩ–—÷‹∆⁄=ATRCLK*(ATRCYC[15:0
             -]+1)=3.1√Î ”–ŒÛ 20220506
 275   1        BC3602_WriteRegister(ATR_CYCLE_L_REGS,0x3a);//ATR2 ATRCT∂® ±∆˜ΩÁœﬁ÷µµÕ◊÷Ω⁄
 276   1        BC3602_WriteRegister(ATR_CYCLE_H_REGS,0x63);//ATR3 ATRCT∂® ±∆˜ΩÁœﬁ÷µ∏ﬂ◊÷Ω⁄ ªΩ–—÷‹∆⁄=ATRCLK*(ATRCYC[15:0]+
             -1)=(1/8192Hz)*(25402+1)=3.101√Î//3.101*8192-1=25402
 277   1        
 278   1        BC3602_WriteRegister(ATR_EACTIVE_L_REGS,0x05);//ATR5 RX¿©’π÷‹∆⁄µÕ◊÷Ω⁄
 279   1        BC3602_WriteRegister(ATR_EACTIVE_H_REGS,0x00);//ATR6 RX¿©’π÷‹∆⁄∏ﬂ◊÷Ω⁄ ¿©’π÷‹∆⁄=µ•Œª ±º‰*ATRRXEP[15:0]+1)=
             -6*250us=1.5ms
 280   1        
 281   1        BC3602_WriteRegister(ARK_CONTROL_REGS,0x72);//ATR7 ARK÷ÿ∏¥÷‹∆⁄¥Œ ˝=8 ◊‘∂ØªΩ–——”≥Ÿ ±º‰=488us ◊‘∂Ø÷ÿ∑¢/ACK=
             -≥˝ƒ‹
 282   1      //  BC3602_WriteRegister(ARK_CONTROL_REGS,0x00);//ATR7 ARK÷ÿ∏¥÷‹∆⁄¥Œ ˝=1 ◊‘∂ØªΩ–——”≥Ÿ ±º‰=244us ◊‘∂Ø÷ÿ∑¢/AC
             -K=≥˝ƒ‹  
 283   1        
 284   1        BC3602_WriteRegister(ARK_ACTIVE_REGS,0x27);//ATR8 ARK RX”––ß÷‹∆⁄ ”––ß÷‹∆⁄=µ•Œª ±º‰ARKRXAP[7:0]+1)=40*250u
             -s=10ms
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 6   

 285   1        BC3602_WriteRegister(ATR_CNTR_L_REGS,0);//ATR9 ATR÷‹∆⁄∂® ±∆˜µÕ◊÷Ω⁄
 286   1        BC3602_WriteRegister(ATR_CNTR_H_REGS,0);//ATR10 ATR÷‹∆⁄∂® ±∆˜∏ﬂ◊÷Ω⁄
 287   1      //  BC3602_WriteRegister(ATR_ACTIVE_L_REGS,0x09);//ATR4 RX”––ß÷‹∆⁄µÕ◊÷Ω⁄
 288   1      //  BC3602_WriteRegister(ATR_ACTIVE_H_REGS,0);//ATR11 RX”––ß÷‹∆⁄∏ﬂ◊÷Ω⁄ ”––ß÷‹∆⁄=µ•Œª ±º‰*ATRRXAP[10:0]+1=10
             -*250us=2.5ms //20201225 7%◊Û”“ ’≤ªµΩ @ªΩ–—÷‹∆⁄3.7√Î
 289   1      
 290   1      //  BC3602_WriteRegister(ATR_ACTIVE_L_REGS,0x13);//ATR4 RX”––ß÷‹∆⁄µÕ◊÷Ω⁄
 291   1      //  BC3602_WriteRegister(ATR_ACTIVE_H_REGS,0);//ATR11 RX”––ß÷‹∆⁄∏ﬂ◊÷Ω⁄ ”––ß÷‹∆⁄=µ•Œª ±º‰*ATRRXAP[10:0]+1=20
             -*250us=5.0ms //20220505 4∏ˆ1◊È≤‚ ‘20¥Œ,π≤2◊È,»´OK @ªΩ–—÷‹∆⁄3.7√Î
 292   1      
 293   1      //  BC3602_WriteRegister(ATR_ACTIVE_L_REGS,0x0b);//ATR4 RX”––ß÷‹∆⁄µÕ◊÷Ω⁄
 294   1      //  BC3602_WriteRegister(ATR_ACTIVE_H_REGS,0);//ATR11 RX”––ß÷‹∆⁄∏ﬂ◊÷Ω⁄ ”––ß÷‹∆⁄=µ•Œª ±º‰*ATRRXAP[10:0]+1=12
             -*250us=3.0ms //20220506 4∏ˆ1◊È≤‚ ‘20¥Œ,π≤2◊È,√ø◊È∏˜”–1∏ˆ ’≤ªµΩ @ªΩ–—÷‹∆⁄3.7√Î
 295   1        
 296   1      //  BC3602_WriteRegister(ATR_ACTIVE_L_REGS,0x0d);//ATR4 RX”––ß÷‹∆⁄µÕ◊÷Ω⁄
 297   1      //  BC3602_WriteRegister(ATR_ACTIVE_H_REGS,0);//ATR11 RX”––ß÷‹∆⁄∏ﬂ◊÷Ω⁄ ”––ß÷‹∆⁄=µ•Œª ±º‰*ATRRXAP[10:0]+1=14
             -*250us=3.5ms //20220506 4∏ˆ1◊È≤‚ ‘20¥Œ,π≤2◊È,»´OK @ªΩ–—÷‹∆⁄3.7√Î
 298   1      
 299   1      //  BC3602_WriteRegister(ATR_ACTIVE_L_REGS,0x09);//ATR4 RX”––ß÷‹∆⁄µÕ◊÷Ω⁄
 300   1      //  BC3602_WriteRegister(ATR_ACTIVE_H_REGS,0);//ATR11 RX”––ß÷‹∆⁄∏ﬂ◊÷Ω⁄ ”––ß÷‹∆⁄=µ•Œª ±º‰*ATRRXAP[10:0]+1=10
             -*250us=2.5ms //20201225 5%◊Û”“ ’≤ªµΩ @ªΩ–—÷‹∆⁄3.1√Î
 301   1      
 302   1        BC3602_WriteRegister(ATR_ACTIVE_L_REGS,0x0b);//ATR4 RX”––ß÷‹∆⁄µÕ◊÷Ω⁄
 303   1        BC3602_WriteRegister(ATR_ACTIVE_H_REGS,0);//ATR11 RX”––ß÷‹∆⁄∏ﬂ◊÷Ω⁄ ”––ß÷‹∆⁄=µ•Œª ±º‰*ATRRXAP[10:0]+1=12*2
             -50us=3.0ms //20220506 4∏ˆ1◊È≤‚ ‘20¥Œ,π≤2◊È,»´OK @ªΩ–—÷‹∆⁄3.1√Î
 304   1      
 305   1      //  BC3602_WriteRegister(XO_CAP_CTL_REGS,65);//
 306   1      //  BC3602_WriteRegister(XO_SEL_CTL_REGS,3);//16.M
 307   1        BC3602_WriteRegister(XO_CAP_CTL_REGS,0x1f);//
 308   1        BC3602_WriteRegister(XO_SEL_CTL_REGS,0x04);//19.2M
 309   1        BC3602_WriteRegister(LIRC_CTL_REGS,26);//
 310   1        BC3602_WriteRegister(TX_POWER_CTL_REGS,0x09);//0x0d
 311   1      
 312   1        BC3602_RegisterBank(REGS_BANK1);
 313   1        BC3602_WriteRegister(AGC_CTL2_REGS,0x40);     //AGC2 //...???
 314   1        BC3602_WriteRegister(AGC_CTL3_REGS,0x24);     //AGC3
 315   1        BC3602_WriteRegister(AGC_CTL4_REGS,0x11);     //AGC4 —°‘Ò◊Ó¥Û‘ˆ“Ê
 316   1        BC3602_WriteRegister(AGC_CTL5_REGS,0x00);     //AGC5
 317   1        BC3602_WriteRegister(AGC_CTL7_REGS,0x30);     //AGC7 //...???
 318   1      //  BC3602_WriteRegister(FILTER_CTL1_REGS,0x06);    //FCF1 ∆Ωª¨¬À≤®∆˜±»¬ 1:1
 319   1      //  BC3602_WriteRegister(FILTER_CTL2_REGS,0x80);    //FCF2 ∆µ¬ ∆´“∆±»¿˝≤Œ ˝µÕ◊÷Ω⁄ 37.5K@100Kbps for19.2M
 320   1        BC3602_WriteRegister(FILTER_CTL3_REGS,0x00);          //FCF3 ∆µ¬ ∆´“∆±»¿˝≤Œ ˝∏ﬂ◊÷Ω⁄
 321   1        BC3602_WriteRegister(FILTER_CTL4_REGS,0x00);          //FCF4
 322   1        BC3602_WriteRegister(FILTER_CTL5_REGS,0x00);          //FCF5
 323   1        BC3602_WriteRegister(FILTER_CTL6_REGS,0x00);          //FCF6
 324   1        BC3602_WriteRegister(FILTER_CTL7_REGS,0x00);          //FCF7
 325   1        BC3602_WriteRegister(FILTER_CTL8_REGS,0x00);          //FCF8
 326   1        BC3602_WriteRegister(FILTER_CTL9_REGS,0x00);          //FCF9
 327   1        BC3602_WriteRegister(FILTER_CTL10_REGS,0x00);         //FCF10
 328   1        BC3602_WriteRegister(FILTER_CTL11_REGS,0x00);         //FCF11
 329   1        BC3602_WriteRegister(FILTER_CTL12_REGS,0x00);         //FCF12
 330   1        BC3602_WriteRegister(FILTER_CTL13_REGS,0x00);//FCF13
 331   1        BC3602_WriteRegister(FILTER_CTL14_REGS,0x00);//FCF14
 332   1        BC3602_WriteRegister(FILTER_CTL15_REGS,0x00);//FCF15
 333   1        BC3602_WriteRegister(FILTER_CTL16_REGS,0x00);//FCF16
 334   1        BC3602_WriteRegister(FILTER_CTL17_REGS,0x00);//FCF17
 335   1        BC3602_WriteRegister(FILTER_CTL18_REGS,0x00);//FCF18
 336   1        BC3602_WriteRegister(FILTER_CTL19_REGS,0x00);//FCF19
 337   1      
 338   1        BC3602_WriteRegister(FILTER_CTL1_REGS,0x00);    //FCF1 ∆Ωª¨¬À≤®∆˜±»¬ 1:1
 339   1        BC3602_WriteRegister(FILTER_CTL2_REGS,0x96);    //FCF2 ∆µ¬ ∆´“∆±»¿˝≤Œ ˝µÕ◊÷Ω⁄ 37.5K@100Kbps for19.2M
 340   1      /******************–¬‘ˆ******************************/  
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 7   

 341   1        BC3602_RegisterBank(REGS_BANK2);
 342   1        BC3602_WriteRegister(BANK2_RSV1,0x03);
 343   1        BC3602_WriteRegister(BANK2_RSV2,0x88);
 344   1        BC3602_WriteRegister(BANK2_RSV3,0xA3);
 345   1        BC3602_WriteRegister(BANK2_RSV4,0x80);
 346   1        BC3602_WriteRegister(BANK2_RSV5,0x16);
 347   1        BC3602_WriteRegister(BANK2_RSV6,0x64);//433:0x64 868:0x74
 348   1        BC3602_WriteRegister(BANK2_RSV7,0x54);//44h/54h (°›100Kbps:54h)
 349   1        BC3602_WriteRegister(BANK2_RSV8,0x00);
 350   1        BC3602_WriteRegister(BANK2_RSV9,0x64);
 351   1        BC3602_WriteRegister(BANK2_RSV10,0xBC);//433:0xBC 868:0x9C
 352   1        BC3602_WriteRegister(BANK2_RSV11,0x94);
 353   1      
 354   1      
 355   1               // Entry Deepsleep mode*/
 356   1         Mflag.RFmode = RF_RX;
 357   1      }
 358          
 359          
 360          
 361          
 362          
 363          
 364          /*void ResetLvRF(void)
 365          {
 366            unsigned char a=0;
 367            while(a == 0)
 368            {
 369              a=SpiReadRegCMD(READ_REGS_CMD|RC1_REGS);
 370              a |= 0x01;
 371              SpiWriteRegCMD(WRITE_REGS_CMD|RC1_REGS,a);
 372              a=SpiReadRegCMD(READ_REGS_CMD|RC1_REGS);
 373              a &= 0xFE;
 374              SpiWriteRegCMD(WRITE_REGS_CMD|RC1_REGS,a);
 375            }
 376          }*/
 377          
 378          //*******************************//
 379          // name   : BC3602_Config
 380          // input  : none
 381          // output : none
 382          //*******************************//
 383          //ÔøΩÔøΩ”¶Œ™ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ16ŒªÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩsizeof ÔøΩ‘∫ÔøΩÔøΩ√µÔøΩÔøΩÔøΩÔøΩÔøΩ µÔøΩÔøΩÔøΩÔøΩÔøΩÔø
             -ΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ“?ÔøΩÔøΩÔøΩ‘∂ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‹µƒµÔøΩÔøΩÔøΩÔøΩÔøΩƒ∏ÔøΩ ?
 384          /*void BC3602_Config(void)
 385          {
 386            unsigned char a=0;
 387            //  BC3601 IRQ/IO Configure //
 388            for(a=0;a<(sizeof IRQIO_REGS_TALBE/2);a++)  SpiWriteRegCMD((WRITE_REGS_CMD|(IRQIO_REGS_TALBE[a]>>8)), IRQI
             -O_REGS_TALBE[a]);
 389            //  BC3602 packet format Configure  //
 390            for(a=0;a<(sizeof PACKET_REGS_TALBE/2);a++) SpiWriteRegCMD((WRITE_REGS_CMD|(PACKET_REGS_TALBE[a]>>8)), PA
             -CKET_REGS_TALBE[a]);
 391            //  BC3602 common Configure //
 392            for(a=0;a<(sizeof COMMON_REGS_TALBE/2);a++) SpiWriteRegCMD((WRITE_REGS_CMD|(COMMON_REGS_TALBE[a]>>8)), CO
             -MMON_REGS_TALBE[a]);
 393            
 394            //  BC3602 Bank0 Configure  //
 395            SpiWriteStrobeCMD(REGS_BANK_CMD|BC3602_BANK0);
 396            for(a=0;a<(sizeof BANK0_REGS_TALBE/2);a++)  SpiWriteRegCMD((WRITE_REGS_CMD|(BANK0_REGS_TALBE[a]>>8)), BANK
             -0_REGS_TALBE[a]);
 397            //  BC3602 Bank1 Configure  //
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 8   

 398            SpiWriteStrobeCMD(REGS_BANK_CMD|BC3602_BANK1);
 399            for(a=0;a<(sizeof BANK1_REGS_TALBE/2);a++)  SpiWriteRegCMD((WRITE_REGS_CMD|(BANK1_REGS_TALBE[a]>>8)), BANK
             -1_REGS_TALBE[a]);
 400            //  BC3602 Bank2 Configure  //
 401            SpiWriteStrobeCMD(REGS_BANK_CMD|BC3602_BANK2);
 402            for(a=0;a<(sizeof BANK2_REGS_TALBE/2);a++)  SpiWriteRegCMD((WRITE_REGS_CMD|(BANK2_REGS_TALBE[a]>>8)), BANK
             -2_REGS_TALBE[a]);
 403            SpiWriteStrobeCMD(REGS_BANK_CMD|BC3602_BANK0);
 404          }*/
 405          
 406          
 407          //*******************************//
 408          // name   : RFWriteBuf
 409          // input  : CMD,length,data[]
 410          // output : none
 411          //*******************************//
 412          void RFWriteBuf(unsigned char CMD,unsigned char length,unsigned char Data[])
 413          {
 414   1        unsigned char a;
 415   1        //SpiCSN_low();
 416   1        BC3602CSN=0 ; 
 417   1        SpiWrite(CMD);
 418   1        for(a=0;a<length;a++) SpiWrite(Data[a]);
 419   1        //SpiCSN_high();
 420   1        BC3602CSN=1 ; 
 421   1      }
 422          
 423          
 424          //*******************************//
 425          // name   : RFWriteSyncword
 426          // input  : none
 427          // output : none
 428          //*******************************//
 429          /*void RFWriteSyncword(void)
 430          {
 431            unsigned char a;
 432            
 433          #if RF_SYNC_BCHcoding
 434            
 435            #if (RF_SYNC_Length != 4)
 436            unsigned char temp1[RF_SYNC_Length];
 437            #endif
 438            
 439            #if (RF_SYNC_Length == 4)
 440            for(a=0;a<4;a++) mLap[a]=BC3602_SYNCWORD[a];
 441            BCH32_Syncword();
 442            RFWriteBuf2(WRITE_SYNCWORD_CMD,RF_SYNC_Length,mRFSync); 
 443            #endif
 444            
 445            #if (RF_SYNC_Length == 6)
 446            for(a=0;a<4;a++) mLap[a]=BC3602_SYNCWORD[a];
 447            BCH32_Syncword();
 448            for(a=0;a<4;a++) temp1[a]=mRFSync[a];
 449            for(a=0;a<2;a++) mLap[a]=BC3602_SYNCWORD[a+4];
 450            mLap[2]=0;
 451            mLap[3]=0;
 452            BCH32_Syncword();
 453            for(a=0;a<2;a++) temp1[a+4]=mRFSync[a];
 454            for(a=0;a<6;a++) mRFSync[a]=temp1[a];
 455            RFWriteBuf2(WRITE_SYNCWORD_CMD,RF_SYNC_Length,mRFSync); 
 456            #endif
 457            
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 9   

 458            #if (RF_SYNC_Length == 8)
 459            for(a=0;a<4;a++) mLap[a]=BC3602_SYNCWORD[a];
 460            BCH32_Syncword();
 461            for(a=0;a<4;a++) temp1[a]=mRFSync[a];
 462            for(a=0;a<4;a++) mLap[a]=BC3602_SYNCWORD[a+4];
 463            BCH32_Syncword();
 464            for(a=0;a<4;a++) temp1[a+4]=mRFSync[a];
 465            for(a=0;a<8;a++) mRFSync[a]=temp1[a];
 466            RFWriteBuf2(WRITE_SYNCWORD_CMD,RF_SYNC_Length,mRFSync); 
 467            #endif
 468            
 469          #else
 470            
 471            for(a=0;a<RF_SYNC_Length;a++)
 472              mRFSync[a] = BC3602_SYNCWORD[a];
 473            RFWriteBuf(WRITE_SYNCWORD_CMD,RF_SYNC_Length,mRFSync);
 474            
 475          #endif
 476            
 477          }*/
 478          
 479          //*********************************************//
 480          // name   : DATA_Process
 481          // input  : RF_TXFIFO
 482          // output : none
 483          //*********************************************//
 484          void DATA_Process(unsigned char *FIFO)
 485          {
 486   1        FIFO++;
 487   1        *FIFO = 0x22;
 488   1        //ÔøΩKÔøΩK
 489   1        //ÔøΩKÔøΩK
 490   1        //ÔøΩKÔøΩK
 491   1        FIFO++;
 492   1        *FIFO = 0x33;
 493   1      }
 494          
 495          //*********************************************//
 496          // name   : KEY_Process
 497          // input  : key_status
 498          // output : none
 499          //*********************************************//
 500          void KEY_BC3602(unsigned char key_status)
 501          {
 502   1        switch(key_status)
 503   1        {
 504   2          case 1:
 505   2            RF_TXFIFO[0] = 0x01;                              // put data into RF_TXFIFO
 506   2            DATA_Process(RF_TXFIFO);                            // put data into RF_TXFIFO
 507   2            Mflag.RFstep = 0;                               // reset RF step
 508   2            Mflag.RFmode = RF_TX;                             // set RF mode flag as TX                             
 509   2            break;
 510   2            
 511   2          case 2:
 512   2            RF_TXFIFO[0] = 0x02;
 513   2            DATA_Process(RF_TXFIFO);
 514   2            Mflag.RFstep = 0;
 515   2            Mflag.RFmode = RF_TX;
 516   2            break;
 517   2            
 518   2          case 3:
 519   2            RF_TXFIFO[0] = 0x03;
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 10  

 520   2            DATA_Process(RF_TXFIFO);
 521   2            Mflag.RFstep = 0;
 522   2            Mflag.RFmode = RF_TX;
 523   2            break;
 524   2            
 525   2          case 4:
 526   2            RF_TXFIFO[0] = 0x04;
 527   2            DATA_Process(RF_TXFIFO);
 528   2            Mflag.RFstep = 0;
 529   2            Mflag.RFmode = RF_TX;
 530   2            break;  
 531   2            
 532   2          default:
 533   2            break;
 534   2        }
 535   1      }
 536          
 537          void PinInterrupt_ISR (void) interrupt 7
 538          {
 539   1          _push_(SFRS);
 540   1        
 541   1          SFRS = 0;
 542   1          switch(PIF)
 543   1          {
 544   2            case 0x01:
 545   2            Mflag.fRFINT = 1; 
 546   2            break;
 547   2            case 0x02:// printf("\n PIT1 interrupt!"); break;
 548   2            default: break;
 549   2          }                 
 550   1          PIF = 0; 
 551   1        
 552   1          _pop_(SFRS);
 553   1      }
 554          
 555          unsigned char Get_RF_Mode(void) 
 556          {
 557   1      return Mflag.RFmode;
 558   1      }
 559          
 560          
 561          
 562          //*******************************//
 563          // name   : WriteFIFO
 564          // input  : none
 565          // output : none
 566          //*******************************//
 567          void WriteFIFO(unsigned char *rf_fifo,unsigned char payload_length)
 568          {
 569   1        unsigned char a=0;  
 570   1        BC3602CSN=0;
 571   1        SpiWrite(WRITE_FIFO_CMD);
 572   1        for(a=0;a<payload_length;a++)
 573   1        {
 574   2          SpiWrite(*rf_fifo);
 575   2          rf_fifo++;
 576   2        }
 577   1        BC3602CSN=1;
 578   1      }
 579          
 580          //*******************************//
 581          // name   : ReadFIFO
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 11  

 582          // input  : none
 583          // output : none
 584          //*******************************//
 585          void ReadFIFO(unsigned char *rf_fifo,unsigned char length)
 586          {
 587   1        unsigned char a=0;  
 588   1        BC3602CSN=0;
 589   1        SpiWrite(READ_FIFO_CMD);
 590   1        for(a=0;a<length;a++)
 591   1        {
 592   2          *rf_fifo = SpiRead();
 593   2          rf_fifo++;
 594   2        }
 595   1        BC3602CSN=1;
 596   1      }
 597          
 598          
 599          /*------------------------------------------------------------------*/
 600          /*               Function               */
 601          /*------------------------------------------------------------------*/
 602          //*******************************//
 603          // name   : SimpleFIFO_TX_Process
 604          // input  : step
 605          // output : RF_Mode
 606          //*******************************//
 607          void SimpleFIFO_TX_Process(unsigned char *step,unsigned char *IRQ,unsigned char *Mode)
 608          {
 609   1        switch(*step)
 610   1        {
 611   2          case 0:
 612   2            SpiWriteStrobeCMD(LIGHT_SLEEP_CMD);                         // RF entry LightSleep mode
 613   2            RFXtalReady();                                    // waitting XTAL ready
*** WARNING C206 IN LINE 613 OF ..\..\..\UserCode\User\src\BC3602.c: 'RFXtalReady': missing function-prototype
 614   2            
 615   2            SpiWriteRegCMD(WRITE_REGS_CMD|IRQ_ENABLE_REGS,0x01);                    // enable TXCMPIF
 616   2            
 617   2            SpiWriteStrobeCMD(REST_TX_POS_CMD);                         // reset RF TX FIFO
 618   2            SpiWriteRegCMD(WRITE_REGS_CMD|TX_DATA_LENG_REGS,RF_Payload_Length);             // set RF TX payload length
 619   2            WriteFIFO(RF_TXFIFO,RF_Payload_Length);                       // write data to RF FIFO
 620   2            
 621   2            SpiWriteStrobeCMD(TX_MODE_CMD);                           // RF entry TX mode
 622   2            (*Mode) = RF_TX;                                  // set RF mode flag as TX
 623   2            (*step)++;                                      // increase RF step
 624   2            break;
 625   2            
 626   2          case 1:
 627   2            if(RF_INT==0)                                   // while RF IQR line being low
 628   2              (*IRQ) = RFGetClrRFIrq();                           // read RF IRQ status
*** WARNING C206 IN LINE 628 OF ..\..\..\UserCode\User\src\BC3602.c: 'RFGetClrRFIrq': missing function-prototype
 629   2            
 630   2            if(RF_IRQ&0x01)                                   // while RF IQR equal TXCMPIF
 631   2            {
 632   3              SpiWriteStrobeCMD(LIGHT_SLEEP_CMD);                       // RF entry LightSleep mode
 633   3              (*Mode) = RF_LightSleep;                            // set RF mode flag as Lightsleep
 634   3              (*step) = 0;                                  // reset RF step
 635   3            }
 636   2            break;
 637   2            
 638   2          default:
 639   2            (*step) = 0;
 640   2            break;
 641   2        }
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 12  

 642   1      }
 643          
 644          
 645          //*******************************//
 646          // name   : SimpleFIFO_RX_Process
 647          // input  : step
 648          // output : RF_Mode
 649          //*******************************//
 650          void SimpleFIFO_RX_Process(unsigned char *step,unsigned char *IRQ,unsigned char *Mode)
 651          {
 652   1        unsigned char a;
 653   1        
 654   1        switch(*step)
 655   1        {
 656   2          case 0:
 657   2            SpiWriteStrobeCMD(LIGHT_SLEEP_CMD);                         // RF entry LightSleep mode
 658   2            RFXtalReady();                                    // waitting XTAL ready
 659   2            
 660   2            SpiWriteRegCMD(WRITE_REGS_CMD|IRQ_ENABLE_REGS,0x12);                    // enable RXERRIF & RXCMPIF
 661   2            
 662   2            for(a=0;a<RF_Payload_Length;a++)                          // clear RF_RXFIFO
 663   2              RF_RXFIFO[a] = 0; 
 664   2            
 665   2            SpiWriteStrobeCMD(REST_RX_POS_CMD);                         // reset RF RX FIFO
 666   2            SpiWriteRegCMD(WRITE_REGS_CMD|RX_DATA_LENG_REGS,RF_Payload_Length);             // set RF RX payload length
 667   2            
 668   2            SpiWriteStrobeCMD(RX_MODE_CMD);                           // RF entry RX mode
 669   2            (*Mode) = RF_RX;                                  // set RF mode flag as RX
 670   2            (*step)++;                                      // increase RF step
 671   2            break;
 672   2            
 673   2          case 1:
 674   2            if(RF_INT==0)                                   // while RF IQR line being low
 675   2              (*IRQ) = RFGetClrRFIrq();                           // read RF IRQ status
 676   2            
 677   2            if(RF_IRQ&0x12)                                   // while RF IQR equal RXERRIF or RXCMPIF
 678   2            {
 679   3              if(RF_IRQ & 0x02)                               // while RF IQR equal RXCMPIF
 680   3                ReadFIFO(RF_RXFIFO,RF_Payload_Length);                    // read RX FIFO
 681   3                memcpy(RF_RXFIFOSAVE,RF_RXFIFO,RF_Payload_Length);
 682   3              SpiWriteStrobeCMD(LIGHT_SLEEP_CMD);                       // RF entry LightSleep mode
 683   3              (*Mode) = RF_LightSleep;                            // set RF mode flag as Lightsleep
 684   3              (*step) = 0;                                  // reset RF step
 685   3              Start_Display_RXData=True;
 686   3            }
 687   2            break;
 688   2            
 689   2          default:
 690   2            (*step) = 0;
 691   2            break;
 692   2        }
 693   1      }
 694           
 695          
 696          
 697          
 698          //*********************************************//
 699          // name   : RF_Finished_Process
 700          // input  : key_status
 701          // output : none
 702          //*********************************************//
 703          void RF_Finished_Process(void)
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 13  

 704          {
 705   1        if(RF_IRQ & 0x01)                                   // while TX finished
 706   1        {
 707   2          RF_IRQ = 0;                                     // clear IRQ flag
 708   2          Mflag.RFmode = RF_RX;                               // set RF mode flag as RX
 709   2          
 710   2          switch(RF_TXFIFO[0])                                // display LED show TX success
 711   2          {
 712   3            case 0x01:
 713   3      //        LEDx_Flash(LED1,1,10);
 714   3              //LED_FLASH(1);
 715   3              break;
 716   3            case 0x02:
 717   3      //        LEDx_Flash(LED2,1,10);
 718   3              //LED_FLASH(2);
 719   3              break;
 720   3            case 0x03:
 721   3      //        LEDx_Flash(LED3,1,10);
 722   3             // LED_FLASH(3);
 723   3              break;
 724   3            case 0x04:
 725   3      //        LEDx_Flash(LED4,1,10);
 726   3              //LED_FLASH(4);
 727   3              break;
 728   3            default:
 729   3              break;
 730   3          }
 731   2          
 732   2        }
 733   1        
 734   1        if(RF_IRQ & 0x12)                                   // while RX finished
 735   1        {
 736   2          RF_IRQ = 0;                                     // clear IRQ flag
 737   2          Mflag.RFmode = RF_RX;                               // set RF mode flag as RX
 738   2          if(RF_IRQ & 0x10)                                 // while RX finished but CRC error
 739   2          {
 740   3            
 741   3            
 742   3            
 743   3          }
 744   2          else                                        // while RX finished and CRC OK
 745   2          {
 746   3            switch(RF_RXFIFO[0])                              // check RF DATA
 747   3            {
 748   4              case 0x01:
 749   4                //LEDx_Flash(LED1,1,10);
 750   4      //          LED_FLASH(1);
 751   4                break;
 752   4              case 0x02:
 753   4                //LEDx_Flash(LED2,1,10);
 754   4                //LED_FLASH(2);
 755   4                break;
 756   4              case 0x03:
 757   4              //  LEDx_Flash(LED3,1,10);
 758   4               // LED_FLASH(3);
 759   4                break;
 760   4              case 0x04:
 761   4                //LEDx_Flash(LED4,1,10);
 762   4                //LED_FLASH(4);
 763   4                break;
 764   4              default:
 765   4                break;
C51 COMPILER V9.60.0.0   BC3602                                                            11/11/2022 18:17:38 PAGE 14  

 766   4            }
 767   3          }
 768   2        }
 769   1      }
 770          
 771          
 772          void BC3602_RF_Process(void)
 773          {
 774   1          BC3602_TX_Process();
 775   1        if(Mflag.RFmode == RF_TX)                                               // while RF mode flag = TX
 776   1          SimpleFIFO_TX_Process(&Mflag.RFstep,&RF_IRQ,&Mflag.RFmode);           // RF Simple FIFO TX porcess  
 777   1        
 778   1        if(Mflag.RFmode == RF_RX)                                               // while RF mode flag = RX
 779   1          SimpleFIFO_RX_Process(&Mflag.RFstep,&RF_IRQ,&Mflag.RFmode);           // RF Simple FIFO RX porcess      
 780   1          RF_Finished_Process();
 781   1         // RF_Finished_Process(RF_IRQ)
 782   1      }
 783            
 784          void Set_RFmode(unsigned char Mode_x)
 785          {
 786   1      switch(Mode_x)                              // check RF DATA
 787   1            {
 788   2              case RF_TX:
 789   2                
 790   2                Mflag.RFmode = RF_TX;
 791   2                break;
 792   2              case RF_RX:
 793   2                Mflag.RFmode = RF_RX;
 794   2                
 795   2                break;
 796   2                break;
 797   2              default:
 798   2                break;
 799   2            }
 800   1      }
 801            
 802          void ReSet_RFstep(void)
 803          {
 804   1      Mflag.RFstep = 0; //
 805   1      }
 806              
 807          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1796    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    106      34
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
